---
layout:       default
class:        markdown
docson:       true
interactive:  true
---

Creating Your First Task
========================

This tutorial will show you how to create a task, as well as how to fetch
both state and artifacts from the task. Later tutorials will show you how to
listen for the events generated by task and how to combine this with custom
routes message.


Constructing a Task Definition
------------------------------

To create a task we must construct a _task definition_, the API reference
documentation for the `queue.taskcluster.net` specifies a JSON schema for both
`queue.defineTask` and `queue.createTask` methods. You may find this schema at
`schemas.taskcluster.net/queue/v1/create-task-request.json`, for reference it
is rendered below.

<div data-render-schema="http://schemas.taskcluster.net/queue/v1/create-task-request.json#"></div>

As evident from the schema there is a few _required_ properties, such as:
`provisionerId`, `workerType`, `created`, `deadline`, `payload` and `metadata`.
The rest of the properties are optional and defaults should be documented.
It should, however, be noted that default values may change over time, so it
is recommended provide those you rely on.

All workers have a `workerType` this identifier is unique given the
`provisionerId`, hence, `provisionerId` and `workerType` uniquely identifies
the pool of workers you are submitting you task to. In practice the
`provisionerId` is embedded in scopes, such that different provisioners can
exist without interfering with each other. For the purpose of this tutorial we
shall use the `b2g-test` workerType from `aws-provisioner-v1`.

A task definition also includes a `created` timestamp, a `deadline` at which
point the _queue_ will resolve the task as `exception` unless the task has been
resolved earlier. This ensures that all tasks will eventually be resolved.
Timestamps are given in UTC as ISO 8601 formatted strings, exactly how
`Date.toJSON()` works. As evident below, `taskcluster-client` has some nice
utilities for constructing relative timestamps for this.

<pre data-plugin="interactive-example">
let taskcluster = require('taskcluster-client');

let task = {
  // Required properties
  provisionerId:      'aws-provisioner-v1',
  workerType:         'b2gtest',
  created:            (new Date()).toJSON(),
  deadline:           taskcluster.fromNowJSON('2 days 3 hours'),
  metadata: {
    // Name and description are meant to be written in markdown
    name:             "Tutorial **Example** Task",
    description:      "Task create from _interactive_ tutorials",
    // Fill in your email
    owner:            'nobody@taskcluster.net',
    // Location of task source, so we can find people with "git blame"
    source:           window.location.href
  },
  payload:            {}, // worker specific payload, we'll add it later

  // Optional properties
  expires:            taskcluster.fromNowJSON('6 months 2 days'),
  // There is more optional properties, but we don't need them here.
};

// Print example task definition
console.log(JSON.stringify(task, null, 2));
</pre>

In the example above you see how to specify the properties required by the
queue. If we were to submit this task to the queue it would be accepted,
however, the worker would immediately reject it because it doesn't carry a
valid `task.payload`. The `task.payload` is specific to the workerType given,
this way we can support multiple platforms and migrate tasks gradually,
keeping legacy workerTypes around until all tasks have been ported.


Constructing a `task.payload` for docker-worker
-----------------------------------------------

The `b2gtest` workerType is a deployment of `docker-worker`, this worker
requires a `task.payload` that specifies which _docker image_ to load, which
command to run and a maximum allowed runtime. You can find detailed
documentation on this site, the schema for the `task.payload` property is
located at `schemas.taskcluster.net/docker-worker/v1/payload.json`, for
reference it is rendered below.

<div data-render-schema="http://schemas.taskcluster.net/docker-worker/v1/payload.json"></div>

For the `image` we can pick any docker image, take a look at
[registry.hub.docker.com](https://registry.hub.docker.com/), you can even build
and upload your own docker images. There are many benefits to using
custom docker images notable ones include:

 * Install dependencies from package repositories and lock them,
 * Make custom scripts and binaries available in the runtime environment, and
 * Test docker images locally before deploying to TaskCluster.

There are many other benefits to docker, but an exhaustive list is beyond the
scope of this document. If you are not familiar with docker you should play
around with  the official docker
[getting started guide](http://docs.docker.com/linux/started/). Deploying Linux
binaries in tasks on TaskCluster is mostly about getting the binaries to run
inside a docker container. For the most part this involves installing
dependencies and configuring them, so become familiar with docker before you
start deploying Linux tasks on TaskCluster.

For the purpose of this tutorial we'll use the official `ubuntu:15.04` docker
image. To make it interesting we'll run two commands `ls && du /usr` that should
show us a little of what the image contains. The example below shows how to
add a payload to the task definition from before.


<pre data-plugin="interactive-example">
let taskcluster = require('taskcluster-client');

let task = {
  provisionerId:      'aws-provisioner-v1',
  workerType:         'b2gtest',
  created:            (new Date()).toJSON(),
  deadline:           taskcluster.fromNowJSON('2 days 3 hours'),
  expires:            taskcluster.fromNowJSON('6 months 2 days'),
  metadata: {
    name:             "Tutorial **Example** Task",
    description:      "Task create from _interactive_ tutorials",
    owner:            'nobody@taskcluster.net',
    source:           window.location.href
  },
  payload: {
    // Properties required by docker-worker
    image:            'ubuntu:15.04',
    command:          ['/bin/bash', '-c', 'ls && du /usr'],
    maxRunTime:       600, // in seconds (600s = 10 minutes)
    // Optional properties
    artifacts: {
      // Export an artifact with the name "public/passwd.txt" and
      // take it from '/etc/passwd' after the task has run.
      "public/passwd.txt": {
        type:         'file',
        path:         '/etc/passwd',
        expires:      taskcluster.fromNowJSON('2 months')
      }
    }
  }
};

// Print example task definition
console.log(JSON.stringify(task, null, 2));
</pre>

To make things a little interesting the example above also exports the file
`/etc/passwd` as an artifact with the name `public/passwd.txt`. It should be
noted that all artifact names that starts with `public/` are public and
accessing them doesn't require any credentials.

Creating a Task
---------------

All tasks have a `taskId` this is
[UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
,version 4, meaning it's 122 random bits. To better fit these UUIDs into URLs,
RabbitMQ routing keys and many other places we always encoded them in
[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5)
stripped of `==` padding. This yields a 22 character identifier like
`a8_YezW8T7e1jLxG7evy-A`.

We call an identifier on this form as a _slugid_, in Javascript we can generate
them using the `slugid` module. Being based on UUID version 4 the risk of
`taskId` collision is extremely small. In fact if you encounter an error
telling you that a given `taskId` is already used by another task, it is most
likely a problem with your retry logic that fails to make idempotent requests,
or you accidentally reused the `taskId`. The example below shows how to generate
a random slugid for use as `taskId`.

<pre data-plugin="interactive-example">
let slugid = require('slugid');

// Generate a new taskId
let taskId = slugid.v4();

// Print the taskId
console.log("Randomly generated taskId: " + taskId);
</pre>

When we have a `taskId` and a _task definition_, we are ready to create a task.
In the example below we'll generate a random `taskId` store it on the `global`
object for use in later examples. Then we construct a task definition, a
`taskcluster.Queue` client with temporary credentials and create a new task
using the `queue.createTask(taskId, payload)` method, where `payload` is the
task definition.

<pre data-plugin="interactive-example">
let taskcluster = require('taskcluster-client');
let slugid      = require('slugid');

// Generate a new taskId
let taskId = slugid.v4();

// Store taskId for use in later examples to fetch status and artifacts
global.taskId = taskId;

// Task definition from previous example
let task = {
  provisionerId:      'aws-provisioner-v1',
  workerType:         'b2gtest',
  created:            (new Date()).toJSON(),
  deadline:           taskcluster.fromNowJSON('2 days 3 hours'),
  expires:            taskcluster.fromNowJSON('6 months 2 days'),
  metadata: {
    name:             "Tutorial **Example** Task",
    description:      "Task create from _interactive_ tutorials",
    owner:            'nobody@taskcluster.net',
    source:           window.location.href
  },
  payload: {
    // Properties required by docker-worker
    image:            'ubuntu:15.04',
    command:          ['/bin/bash', '-c', 'ls && du /usr'],
    maxRunTime:       600, // in seconds (600s = 10 minutes)
    // Optional properties
    artifacts: {
      // Export an artifact with the name "public/passwd.txt" and
      // take it from '/etc/passwd' after the task has run.
      "public/passwd.txt": {
        type:         'file',
        path:         '/etc/passwd',
        expires:      taskcluster.fromNowJSON('2 months')
      }
    }
  }
};

// Create a Queue client object w. temporary credentials
let queue = new taskcluster.Queue({
  credentials: JSON.parse(localStorage.credentials)
});

// Create task
let result = await queue.createTask(taskId, task);

// Print results
console.log("Created task:\n" + JSON.stringify(result.status, null, 2));
console.log("Inspect it at:");
console.log("https://tools.taskcluster.net/task-inspector/#" + taskId);
</pre>

If you are curious about the `createTask(taskId, payload)` method you can look
it up in the [API docs](/queue/api-docs/) for the Queue. You should notice that
the API docs lists a `Signature` property, like
`Signature: createTask(taskId, payload) : result`, these signature are used to
call methods in automatically generated client libraries. This allows for
consistent and well-documented client libraries across all platforms.


Fetch for Task State
--------------------

<pre data-plugin="interactive-example">
let taskcluster = require('taskcluster-client');
let assert      = require('assert');

// Check that we have a taskId on global object from previous example
assert(global.taskId, "You must create a task w. a taskId first!");

// Create Queue client object (no credentials needed for queue.status)
let queue = new taskcluster.Queue();

// Fetch task status, given the taskId from the `global` object
let result = await queue.status(global.taskId);

// Print status
if (['completed', 'failed', 'exception'].indexOf(result.status.state) !== -1) {
  console.log("Task is now resolved... continue to next step");
} else {
  console.log("Task isn't resolved yet, you can inspect it at:");
  console.log("https://tools.taskcluster.net/task-inspector/#" + global.taskId);
}
console.log("\nTask status structure:");
console.log(JSON.stringify(result.status, null, 2));
</pre>

    * task status structure schema
    * Explain runs, last run is always the latest
       - Created when we retry due to infrastructure failure
       - Generally you should **only** care about the latest run
    * queue.status(global.taskId)


Download Task Artifacts
-----------------------
    * queue.listArtifacts(global.taskId, runId = 0)
    * artifactUrl = queue.buildSignedUrl(queue.getArtifact, taskId, runId)
    * artifactUrl = queue.buildUrl(queue.getArtifact, taskId, runId)
    * superagent.get(artifactUrl)



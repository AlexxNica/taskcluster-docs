---
order: 6
title: Temporary Credentials
---
Temporary Credentials
=====================

Any client with a `clientId` and an `accessToken` can issue temporary
credentials with a subset of its [scopes](scopes). Temporary credentials consist of
a `clientId`, `temporaryAccessToken` and a certificate validating them.

Temporary credentials always have an explicit start and expiry date, which can
be up to 31 days apart. A set of temporary credentials cannot be used to issue
new temporary credentials, but they be used to generate signed URLs for
untrusted sources.

A certificate looks as follows and must be attached to all requests in Hawk's `ext` property.

```js
ext = {
  // ...
  certificate: {
    version:          1,
    scopes:           ['ScopeA', 'ScopeB'],
    start:            1410399435102,
    expiry:           1410399497349,
    seed:             'KpJvYUNXSYeWqc0vnsAq9wJJgvWv5pTh6IYhd120YZTQ',
    signature:        'Yw1ETAM+6PGA0T65IAEShwyDLDQqw7M8qpFzLpG+Nm8='
  }
}
```

The certificate is always issued by a client, called the issuer, who must
have a `clientId` and an `accessToken`. In the certificate the `version` must
always be `1` (at least for now).

The `scopes` property is a list of scopes the temporary credentials should have
access to, this must be satisfied by the issuer's scopes.  In other words, the
temporary credentials cannot have any scope that the issuer does not have.

The `start` and `expiry` properties are the validity start and expiration of the
certificate, respectively. Both `start` and `expiry` are in milliseconds since
unix epoch, and these cannot be more than 31 days apart. Notice that it is
allowed to issue temporary credentials that take effect in the future, useful
for delegating access to scheduled tasks.

The `seed` property is a 44 character string of random characters, it used for
construction of the `temporaryAccessToken`, as detailed later. The `signature`
property validates the authenticity of the certificate and is generated as
detailed below.

Named Temporary Credentials
---------------------------

It is often useful to have the clientId indicate something about the user
responsible for the API call.  For example, the clientId `tc-login` issues
temporary credentials to users, but including `"tc-login"` in a logfile is not
of much use.  By specifying `tc-login` as issuer, this service can create
temporary credentials with more descriptive clientIds, such as
`tc-login/sso/someuser@mozilla.com`.

This is accomplished by including the actual cliendId used to issue the
temporary credentials in the  `issuer` property of the certificate.  The
issuer must have the scope `auth:create-client:<clientId>`, and any use of the
credential must use clientId as the Hawk ID.

Signature Generation
--------------------
The signature for a certificate is generated by the issuer, the client that
issues the temporary credentials. The issuer does this by generating a
base64 encoded sha256 HMAC signature of the following string using the
issuer's `accessToken`.

```
version:1\n
seed:<seed>\n
start:<start>\n
expiry:<expiry>\n
scopes:\n
<scopes[0]>\n
<scopes[1]>\n
...
<scopes[n]>
```

or, for named temporary credentials:

```
version:1\n
clientId:<clientId>\n
issuer:<issuer>\n
seed:<seed>\n
start:<start>\n
expiry:<expiry>\n
scopes:\n
<scopes[0]>\n
<scopes[1]>\n
...
<scopes[n]>
```

These cases can be distinguished by the presence or absence of the `issuer`
property in the certificate.  The `clientId` must match the provided
`clientId`.

In the certificate example from previous section, the string to sign would be:

```
version:1\n
seed:KpJvYUNXSYeWqc0vnsAq9wJJgvWv5pTh6IYhd120YZTQ\n
start:1410399435102\n
expiry:1410399497349\n
scopes:\n
ScopeA\n
ScopeB
```

An authenticating server will validate the certificate on every request, using
the above signature algorithm.


Construction of `temporaryAccessToken`
--------------------------------------
The `temporaryAccessToken` must also be generated by the issuer, the client
that issues the temporary credentials. The issuer does this by generating an
sha256 HMAC signature of the `seed` from the certificate, signed with the
issuers `accessToken`.

The signature must be encoded using URL-safe base64 encoding without `=`
padding. See [RFC 4648, sec. 5](http://tools.ietf.org/html/rfc4648#section-5)
for details on URL-safe base64. Basically it amounts to replacing `+` with `-`
and replacing `/` with `_`, and then drop `=` padding.

The resulting HMAC signature is the `temporaryAccessToken`, which should be
given to client that will be using the temporary credentials. **Note**, the
`temporaryAccessToken` will be reconstructed on the authenticating server for
each request.


Authenticating with Temporary Credentials
-----------------------------------------

Temporary credentials come in the form of a `clientId`, `accessToken`, and
`certficate`.  To use such credentials, pass the `clientId` and `accessToken` to Hawk,
and include the `certificate` as a property of Hawk's `ext` field.  In JavaScript:

```js
ext = new Buffer(JSON.stringify({certificate: cert})).toString('base64');
```

**Remark**, it is possible to _restrict authorized scopes_ using the `ext` in
combination with the certificate for a set of temporary credentials. Just merge
the two base64 encoded JSON objects, before base64 encoding and transmission
over the `ext` property.
